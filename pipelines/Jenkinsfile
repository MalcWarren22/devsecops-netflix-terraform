pipeline {
  agent any

  environment {
    AWS_REGION = 'us-east-2'
    ROLE_ARN   = 'arn:aws:iam::902917581625:role/devsecops-netflix-dev-jenkins-deploy-role'
    TF_DIR     = 'stacks/tools-ec2'
    CREDS_FILE = '.aws_sts_env'
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }

    stage('Assume Deploy Role') {
      steps {
        sh '''
          bash -lc '
            set -euo pipefail

            # Assume role and capture creds
            CREDS=$(aws sts assume-role \
              --role-arn "$ROLE_ARN" \
              --role-session-name "jenkins-${BUILD_NUMBER}")

            AWS_ACCESS_KEY_ID=$(echo "$CREDS" | jq -r ".Credentials.AccessKeyId")
            AWS_SECRET_ACCESS_KEY=$(echo "$CREDS" | jq -r ".Credentials.SecretAccessKey")
            AWS_SESSION_TOKEN=$(echo "$CREDS" | jq -r ".Credentials.SessionToken")

            # Persist creds for subsequent stages (exports in one sh step do NOT persist)
            cat > "$CREDS_FILE" <<EOF
export AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
export AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
export AWS_SESSION_TOKEN=${AWS_SESSION_TOKEN}
export AWS_REGION=${AWS_REGION}
export AWS_DEFAULT_REGION=${AWS_REGION}
EOF
            chmod 600 "$CREDS_FILE"

            # Prove identity
            source "$CREDS_FILE"
            aws sts get-caller-identity
          '
        '''
      }
    }
    
    stage('Setup tfenv') {
  steps {
    sh '''
      bash -lc '
        set -euo pipefail

        # Install tfenv locally if missing
        if [ ! -d "$WORKSPACE/.tfenv" ]; then
          git clone https://github.com/tfutils/tfenv.git "$WORKSPACE/.tfenv"
        fi

        export PATH="$WORKSPACE/.tfenv/bin:$PATH"

        # Install and use Terraform version from .terraform-version
        tfenv install
        tfenv use

        terraform version
      '
    '''
  }
}

    stage('Terraform fmt') {
      steps {
        sh '''
          bash -lc '
            set -euo pipefail
            source "$CREDS_FILE"

            cd "$TF_DIR"
            terraform fmt -check -recursive
          '
        '''
      }
    }

    stage('Terraform init/validate') {
      steps {
        sh '''
          bash -lc '
            set -euo pipefail
            source "$CREDS_FILE"

            cd "$TF_DIR"
            terraform init -input=false
            terraform validate
          '
        '''
      }
    }

    stage('TFLint') {
      steps {
        sh '''
          bash -lc '
            set -euo pipefail
            source "$CREDS_FILE"

            cd "$TF_DIR"

            # Install tflint locally (no sudo)
            if ! command -v tflint >/dev/null 2>&1; then
              mkdir -p "$WORKSPACE/.tflint-bin"
              TMPDIR=$(mktemp -d)

              # Download latest tflint (linux amd64)
              curl -sSL -o "$TMPDIR/tflint.zip" \
                "https://github.com/terraform-linters/tflint/releases/latest/download/tflint_linux_amd64.zip"

              unzip -o "$TMPDIR/tflint.zip" -d "$WORKSPACE/.tflint-bin" >/dev/null
              chmod +x "$WORKSPACE/.tflint-bin/tflint"
              rm -rf "$TMPDIR"
            fi

            export PATH="$WORKSPACE/.tflint-bin:$PATH"

            tflint --version
            tflint --init

            # Cruise-mode: do not fail the build on warnings
            tflint -f compact --force
          '
        '''
      }
    }

    stage('Terraform plan') {
      steps {
        withCredentials([file(credentialsId: 'tools-ec2-dev-tfvars', variable: 'TFVARS_PATH')]) {
          sh '''
            bash -lc '
              set -euo pipefail
              source "$CREDS_FILE"

              cd "$TF_DIR"

              # Create plan file for guard checks (with vars)
              terraform plan -input=false -no-color -var-file="$TFVARS_PATH" -out=tfplan

              # Human-readable output
              terraform show -no-color tfplan

              # Machine-readable output for guard stage
              terraform show -json tfplan > tfplan.json
            '
          '''
        }
      }
    }

    stage('Plan Guard (Block world-open SSH/RDP)') {
  steps {
    sh '''
      bash -lc '
        set -euo pipefail
        cd "$TF_DIR"

        echo "USING PLAN GUARD v3"

        cat > guard.jq << "EOF"
[
  .resource_changes[]
  | select(.change.after != null)
  | if .type == "aws_security_group_rule" then
      select((.change.after.type // "") == "ingress")
      | select((.change.after.cidr_blocks // []) | index("0.0.0.0/0"))
      | select(
          ((.change.after.from_port // -1) <= 22 and 22 <= (.change.after.to_port // -1))
          or
          ((.change.after.from_port // -1) <= 3389 and 3389 <= (.change.after.to_port // -1))
        )
      | {
          address: .address,
          kind: "aws_security_group_rule",
          protocol: (.change.after.protocol // "unknown"),
          from_port: (.change.after.from_port // null),
          to_port: (.change.after.to_port // null),
          cidrs: (.change.after.cidr_blocks // [])
        }
    elif .type == "aws_security_group" then
      .change.after.ingress? // []
      | .[]
      | select((.cidr_blocks // []) | index("0.0.0.0/0"))
      | select(
          ((.from_port // -1) <= 22 and 22 <= (.to_port // -1))
          or
          ((.from_port // -1) <= 3389 and 3389 <= (.to_port // -1))
        )
      | {
          address: .address,
          kind: "aws_security_group_ingress_inline",
          protocol: (.protocol // "unknown"),
          from_port: (.from_port // null),
          to_port: (.to_port // null),
          cidrs: (.cidr_blocks // [])
        }
    else
      empty
    end
]
EOF

        violations=$(jq -c -f guard.jq tfplan.json)
        count=$(echo "$violations" | jq length)

        if [ "$count" -gt 0 ]; then
          echo "PLAN GUARD FAILED: World-open SSH/RDP detected (0.0.0.0/0 on 22 or 3389)"
          echo "$violations" | jq .
          exit 1
        fi

        echo "PLAN GUARD PASSED: No world-open SSH/RDP"
      '
    '''
  }
}

    stage('Terraform apply (manual gate)') {
      when {
        branch 'main'
      }
      steps {
        input message: "Apply Terraform in ${env.TF_DIR} to AWS?", ok: "Apply"
        withCredentials([file(credentialsId: 'tools-ec2-dev-tfvars', variable: 'TFVARS_PATH')]) {
          sh '''
            bash -lc '
              set -euo pipefail
              source "$CREDS_FILE"

              cd "$TF_DIR"
              terraform apply -input=false -auto-approve tfplan
            '
          '''
        }
      }
    }
  }

  post {
    always {
      sh '''
        bash -lc '
          rm -f "$CREDS_FILE" || true
          rm -f "$TF_DIR/tfplan" "$TF_DIR/tfplan.json" || true
        '
      '''
    }
  }
}
